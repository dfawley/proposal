# gRPC Binary Logging

*   Author(s): Yuchen Zeng
*   Approver: a11r
*   Status: In Review
*   Implemented in:
*   Last updated: 07/18/2018
*   Discussion at:

## Abstract

Provide binary logging functionality in gRPC.

## Background

gRPC binary logging logs RPCs in binary format. RPC logs generated from
production traffic will be useful in the following cases:

-   Troubleshooting services, find exceptions
-   Loadtesting
-   Reply RPCs from production

This functionality should be added in each of our supported languages. The ease
of adoption should also be considered.

## Proposal

The proposed design is adding binary logging as a built-in functionality in
gRPC. Users can turn it on/off by setting the `GRPC_BINARY_LOG_FILTER`
environment variable. It's not required to modify application code to generate
logs. The control interface should allow users to change the amount and contents
of logs.

### Log Format

gRPC logs each RPC in the format defined by proto GrpcLogEntry. Initial/trailing
metadata and messages are logged separately to match the on-the-wire
representation.

The proto of GrpcLogEntry:

```
// Log entry we store in binary logs
message GrpcLogEntry {
  // Enumerates the type of logs
  enum Type {
    SEND_INITIAL_METADATA = 0;
    SEND_TRAILING_METADATA = 1;
    SEND_MESSAGE = 2;
    RECV_INITIAL_METADATA = 3;
    RECV_TRAILING_METADATA = 4;
    RECV_MESSAGE = 5;
  };

  // Enumerates the entity that generates the log entry
  enum Logger {
    CLIENT = 0;
    SERVER = 1;
  }

  Type type = 1;      // One of the above Type enum
  Logger logger = 2;  // One of the above Logger enum

  // Uniquely identifies a call. Each call may have several log entries, they
  // will share the same call_id. 128 bits split into 2 64-bit parts.
  Uint128 call_id = 3;

  // The logger uses one of the following fields to record the payload,
  // according to the type of the log entry.
  oneof payload {
    // Used by CLIENT_INIT_METADATA, SERVER_INIT_METADATA and TRAILING_METADATA
    Metadata metadata = 4;
    // Used by REQUEST and RESPONSE
    Message message = 5;
  }

  // Peer address information, will only be recorded in SEND_INITIAL_METADATA
  // and RECV_INITIAL_METADATA entries.
  Peer peer = 6;
};

// Message payload, used by REQUEST and RESPONSE
message Message {
  // This flag is currently used to indicate whether the payload is compressed,
  // it may contain other semantics in the future. Value of 1 indicates that the
  // binary octet sequence of Message is compressed using the mechanism declared
  // by the Message-Encoding header. A value of 0 indicates that no encoding of
  // Message bytes has occurred.
  uint8 flags = 1;
  // Length of the message. It may not be the same as the length of the
  // data field, as the logging payload can be truncated or omitted.
  uint32 length = 1;
  // Binary payload, post compression (depends on the flags field), may be
  // truncated or omitted.
  bytes data = 2;
}

// A list of metadata pairs, used in the payload of CLIENT_INIT_METADATA,
// SERVER_INIT_METADATA and TRAILING_METADATA
message Metadata {
  repeated MetadataEntry entry = 1;
}

// A metadata key value pair
message MetadataEntry {
  string key = 1;
  bytes value = 2;
}

// Peer information
message Peer {
  enum PeerType {
    PEER_IPV4 = 0;  // peer is struct sockaddr_in
    PEER_IPV6 = 1;  // peer is struct sockaddr_in6
    PEER_UNIX = 2;  // peer is struct sockaddr_un
  };
  PeerType peer_type = 1;
  bytes peer = 2;  // value depends on peer_type
}

// Used to record call_id.
message Uint128 {
  fixed64 high = 1;
  fixed64 low = 2;
};
```

A call id should be enclosed in each log record, so that the analyzer can use it
to group records generated by the same call. The generation of call id can be
separated from the log generation code, and provided as an interface. In the
open source version, we can generate and assign call id according to the channel
and stream information. At the beginning of each RPC, the gRPC client generates
a call id and sends it to the server in the client initial metadata. This call
id and the client/server address will be enclosed in each log entry on both the
server and client sides. The call id should be unique in each client. The
analyzer can later use the call id and the client/server address to match the
log records generated by the same call.

### Control Interface

The control interface of gRPC binary logging should express the amount and
contents of logs clearly and directly.

gRPC binary logging is turned off by default. Setting the
`GRPC_BINARY_LOG_FILTER` environment variable to a filter string can turn on
binary logging for methods whose full names (in the form of
`/<package>.<service>/<method>`) match the filter.

The format of a filter is a ','-separated list of method patterns. A pattern is
in the form of `<package>.<service>/<method>` or just a character "*". It can be
optionally followed by a "`{[h:<header_length>],[m:<message_length>]}`" string.
By default, the full header or message will be logged. If a header or message
length is given and the entry size is larger than the given length, a truncated
entry will be logged.

*   If the pattern is "*", it specifies the defaults for all the services.
*   If the pattern is `<package>.<service>/*`, it specifies the defaults for all
    methods in the specified service `<package>.<service>`
*   Specifying a method while wildcarding the service is not supported, i.e.
    `*/<method>` is not supported.

If the full name of a method can match several patterns in the filter string,
the most exact match will be used. For example, let's say we have a filter
string with two patterns:

```
    GRPC_BINARY_LOG_FILTER=Foo/*{h},Foo/Bar{m:256}
```

For an RPC for Foo/Bar, we will use the second pattern, because it exactly
matches the service and method name.

For an RPC for Foo/Baz, we will use the first pattern, because it provides the
default for all methods in service Foo.

Example filter strings:

*   `GRPC_BINARY_LOG_FILTER=` Nothing will be logged

*   `GRPC_BINARY_LOG_FILTER=*` All headers and messages will be fully logged.

*   `GRPC_BINARY_LOG_FILTER=*{h}` Only headers will be logged.

*   `GRPC_BINARY_LOG_FILTER=*{m:256}` Only the first 256 bytes of each message
    will be logged.

*   `GRPC_BINARY_LOG_FILTER=Foo/*` Logs every method in service Foo

*   `GRPC_BINARY_LOG_FILTER=Foo/*,-Foo/Bar` Logs every method in service Foo
    except method /Foo/Bar

*   `GRPC_BINARY_LOG_FILTER=Foo/*,Foo/Bar{m:256}` Logs the first 256 bytes of
    each message in method /Foo/Bar, logs all headers and messages in every
    other method in service Foo.

### Log generation

In the binary logging library, a filter/interceptor should be introduced in our
supported languages. This filter monitors the operations of sending and
receiving metadata/messages. At each of these operation, this newly added filter
checks the `GRPC_BINARY_LOG_FILTER` environment variable, and decides whether
the log should be generated. If the flag has been turned on, the filter should
wrap the metadata/message with some system and peer information, and then send
them to the logging interface (remote logging service on diskless servers, or
file based logging in the open source version). As the binary logging filter
will be working with gRPC C core, gRPC wrapped languages do not need to
implement the log generation by itself.

### Pluggability

gRPC binary logging should serve as a separate library, making it convenient to
be changed or even replaced. Configuration knobs should be exposed directly via
this binary logging library. The production target can remove this library
according to its need to minimize the target size. In the built-in approach,
this library should be glued inside the gRPC target, and should be transparent
to users. Other parts of gRPC code should not depend on this library, so that it
could be removed without any trouble.

## Future Work

### Content Filter

As the RPC content may have sensitive data (e.g. encryption keys) that must not
be logged for any period of time, gRPC Binary logging should provide content
filter APIs to help filter out these data. With the content filter, users can
enable gRPC binary logging on methods that may contain sensitive data.

Two types of filter APIs should be provided, one for headers, one for messages.
Pseudo interfaces:

```
void SetHeaderFilter(HeaderKey key, HeaderFilter filter)
void SetMessageFilter(MessageType message, MessageFilter filter)
```

HeaderFilter should accept an RPC header. It may return another header (with the
same key as input) that should be used as the payload, or return an empty object
if the original header is to be used as is.

MessageFilter should accept an proto message. It may return another proto
message (of the same type as input) that should be used as the payload, or
return an empty object if the original message is to be used as is.

The content filter may improve the usability of gRPC binary logging in
troubleshooting production services. But as service owners can fully disable
gRPC binary logging on methods that have sensitive data, the content filter is
not required at the first stage, and may be delivered later as a separate
feature.

## Appendix

### Alternatives

We have another potential way of adding the binary logging functionality in
gRPC.

*   Providing binary logging as a standalone library that is independent from
    gRPC. To enable the log generation, users will need to link in this library.
    An RPCLogger class will be provided in this library. In the application
    code, users have to call the corresponding methods in this class to log
    request/response.

The first approach is preferred, since it does not require any change in the
application code.
